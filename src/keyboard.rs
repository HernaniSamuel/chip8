// This code is generated by Claude, IO isn't my focus, my focus is on the CPU and the fetch-decode-execute cycle
use minifb::{Key, Window};

const KEY_MAP: [(Key, usize); 16] = [
    (Key::X, 0x0),
    (Key::Key1, 0x1),
    (Key::Key2, 0x2),
    (Key::Key3, 0x3),
    (Key::Q, 0x4),
    (Key::W, 0x5),
    (Key::E, 0x6),
    (Key::A, 0x7),
    (Key::S, 0x8),
    (Key::D, 0x9),
    (Key::Z, 0xA),
    (Key::C, 0xB),
    (Key::Key4, 0xC),
    (Key::R, 0xD),
    (Key::F, 0xE),
    (Key::V, 0xF),
];

#[derive(Debug, Clone)]
pub enum KeyboardError {
    InvalidKey,
}

pub struct Keyboard {
    keys: [bool; 16],
}

impl Keyboard {
    pub fn new() -> Self {
        Keyboard { keys: [false; 16] }
    }

    // Called every frame to sync physical keyboard state
    pub fn update(&mut self, window: &Window) {
        for (physical_key, chip8_key) in KEY_MAP {
            self.keys[chip8_key] = window.is_key_down(physical_key);
        }
    }

    pub fn is_pressed(&self, key: usize) -> Result<bool, KeyboardError> {
        if key >= 16 {
            Err(KeyboardError::InvalidKey)
        } else {
            Ok(self.keys[key])
        }
    }
}

impl Default for Keyboard {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_keyboard_bounds() {
        let keyboard = Keyboard::new();
        assert!(keyboard.is_pressed(0x0).is_ok());
        assert!(keyboard.is_pressed(0xF).is_ok());
        assert!(keyboard.is_pressed(0x10).is_err());
    }

    #[test]
    fn test_keyboard_initial_state() {
        let keyboard = Keyboard::new();
        for key in 0..16 {
            assert_eq!(keyboard.is_pressed(key).unwrap(), false);
        }
    }
}
