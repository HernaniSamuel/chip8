Dia 1 - 16/02/2026
Encontrei um pdf de um tcc da usp que descreve bem o chip8 e o processo de emulação, vou me basear nele, ele já fez o que eu ia fazer sozinho.
Isso me permite apenas arquitetar a solução baseada nas especificações já descritas por ele.
O nome do artigo é "Iniciando no desenvolvimento de emuladores com CHIP-8" feito por Diego Pereira Alvarez

ARQUITETURA
enum de instruções
vetor [u8; 16] para os registradores
vetor [u16; 2] para os outros dois registradores que apontam para endereços na memória
stack com 4096 u8 [u8; 4096] para a memória do chip8
Módulo de CPU, Som e Tela serão necessários para uma boa divisão de responsabilidades
struct cpu, struct sound, struct screen, estas vão refletir bem a robustez da arquitetura
Vou ter que usar algumas crates para não reinventar a roda na parte da tela e do som, o foco é aprendeder sobre o funcionamento de hardware
A memória de vídeo é uma matriz 64x32 de booleanos [[bool; 64]; 32] que indicam quais pixels estão pretos ou brancos

Obs: terei que ver a especificação oficial e descrever os estados e transições do sistema antes de começar a arquitetar de fato, o PDF não se aprofundou
o bastante para que eu pudesse aproveitar dele mas foi útil para uma introdução geral de emuladores e do chip8! 
Acredito que eu venha a fazer isso no Notion, o que vai ajudar pra caramba na readme futuramente

Dia 2 - 18/02/2026
Eu entendi, não preciso arquitetar uma arquitetura que já está pronta, o Chip-8 já é a arquitetura em si... Bom, vou focar em implementar então, fazendo
código bem modularizado e profissional.
Primeiramente, separando CPU, Keyboard, Sound e Screen como eu já tinha proposto, divisão de responsabilidades facilita manutenção e escalabilidade...
Optei por não modularizar demais, o próprio chip-8 é bem monolítico pelo que entendi, não divide muito as responsabilidades. Então optei por fazer uma
struct chip8 contendo todos os atributos e estados possíveis da máquina e módulos separados encapsulam a transição de estados para garantir a segurança
e para que o arquivo não fique gigante com tudo no mesmo lugar, aí a manutenção continua fácil e a escalabilidade também continua facilmente possível
Eu tentei separar mais, colocando cada módulo com seu estado e encapsulamento mas acabou que teve muito boilerplate, sinal de overengineering que não agrega em nada.
Estou usando o ChatGPT como documentação interativa e como "mentor", ainda estou muito confuso, mas me recuso a usar ele diretamente no código, ele nem sabe que estou usando Rust.
Ok, acabei de perceber que a struct Chip8 deve conter suas próprias funções de modificação de estado de forma segura, tipo advance_pc enquanto outros módulos como cpu contém a lógica
que pede ao chip8 para mudar seu estado (por exemplo o execute pedindo para avançar o pc)
Chip8 contém os estados e os setters que modificam de forma segura enquanto os outros módulos tem a lógica que pede Chip8 para modificar seus estados... Chip8 é o hardware bruto.
Ok, centralizar todos os métodos que alteram os estados de Chip8 no impl Chip8 é overkill mas eu vou fazer assim mesmo porque já tá me dando TOC ver outros componentes podendo
mudar estados do chip8 sem pedir pra ele... 
Sim, é overkill, mas não me importo, está satisfatório! E também vou fazer o risc-v depois do chip-8, então o chip-8 é meio que uma preparação pro risc-v
Me esqueci totalmente dos testes, era pra eu fazer a função no impl e o teste completo dela, mas aí fui fazendo só as funções, agora vou ter que fazer todos os testes
Os testes em Rust são mais fáceis que os testes em python, é bem satisfatório de fazer eles e dar cargo test pra ver se tá tudo certo!
A meta de amanhã é acabar esses testes pra poder avançar pra CPU em paz (dessa vez fazendo os testes junto com as funcionalidades...)

Dia 3 - 19/02/2026
Estou escrevendo o restante dos testes para garantir que a struct Chip8 está garantindo a transição de estados e a segurança da memória. No emulador original não tem tudo isso
mas eu estou fazendo assim para me preparar para fazer sistemas maiores que vão precisar desse nível de atenção.
Os testes já mostraram serviço ao indicarem o mal funcionamento da função set_i, que deveria atribuir i antes de conferir se i passou dos limites e emitir erro caso necessários
O que o compilador não pega, os testes pegam, por isso que gosto de Rust, é a única linguagem que dá pra escrever o próprio código sem perder a sanidade em runtime...
Se compila, é quase 100% de certeza que vai funcionar do jeito que foi projetado pra funcionar, sem erros, seguro!
Também gosto do jeito que a linguagem força a modelagem de estados e suas transições sem esquecer um caso e sem permitir estados inválidos, definitivamente uma ótima linguagem de sistemas!
É realmente terapêutico ver o sistema de tipos e os testes barrando todos os erros possíveis (ou ao menos 99.999% deles) antes mesmo de gerar o binário! Eu gosto dessa autonomia e segurança!
Acabei os testes da struct Chip8, agora posso definir como vai ser a parte de I/O, acredito que ela também venha a ser conectada na struct Chip8 mas de um jeito diferente, Chip8 vai chamar
funções vindas dos módulos que carregam o tratamento de teclas... ou então vai ser o contrário com esses módulos checando o estado de Chip8 e decidindo... hmmm vou ver isso amanhã...
Por hoje eu fiz tudo o que me propuz a fazer!